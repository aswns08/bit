<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>기본 객체: Object(), Number(), String()</title>

</head>

<body>

<script>
 "use strict"; // 엄격한 문법 검사를 요구함

 var student = {
		 name: "홍길동",
		 kor: 100,
		 eng: 100,
		 math: 100,
		 toString: function() { // 기존에 등록된 함수를 재정의 한다.
			 return this.name + "," + this.kor + "," + this.eng + ',' + this.math ;
		 }
 };
 
 console.log(typeof student);
 
 //prototype 객체들이 공유하는 변수나 함수
 
 // Object.prototype.hasOwnProperty("프로퍼티명")
 // => 객체에 지정된 이름을 갖는 프로퍼티가 있는지 조사하는 함수
 console.log(student.hasOwnProperty('kor'));
 console.log(student.hasOwnProperty('age'));
 
 // Object로 초기화된 객체는 Object의 공용함수 propertype을 통해서 함수를 호출할 수 있다.
 
 // Object.property.toString()
 // =>객체에 대해 문자열로 설명
 console.log(student.toString());
 console.log(student); 
 
 console.log("-----------------------");
 // Number()
 var n1 = 20;
 var n2 = new Number(30);
 
 console.log(typeof n1); // number
 console.log(typeof n2); // object
 
 var n3 = n1 - n2;
 console.log(n3, typeof n3); // -10, number
 
 // 자바스크립트의 모든 생성자는 꼭대기에 Object()와 연결되어 있다.
 // instanceof => 해당 객체가 지정된 생성자로 초기화되었는지 조사한다.
 console.log(n2 instanceof Object); // true
 // n2는 Object의 객체이냐 
 console.log(n2 instanceof Number); // true 
 // n2는 Number의 객체이냐
	 
 console.log(n1 instanceof Object); // false
 console.log(n1 instanceof Number); // false
 
 console.log(n2.toFixed()); // 30
 // n1(number) => Number() 생성자의 함수를 호출 할 수 있다.
 // Number의 함수를 호출하는 순간 Number 객체로 다룬다.
 // 객체가 아님에도 불구하고 Number객체처럼 다룰 수 있도록 해준다
 // 즉 유연하게 사용할 수 있다
 console.log(n1.toFixed()); // 20
 console.log(typeof n1); // number
 
 // 변수가 숫자인지 알아내고자 할 때
 console.log(n1.constructor); // Number
 console.log(n2.constructor); // Number
 
 if(n1.constructor == Number) {
	 console.log('n1은 숫자이다.');
 }
 if(n2.constructor == Number) {
	 console.log('n2는 숫자이다.');
 }

 console.log(Number.MAX_VALUE);
 console.log(Number.MIN_VALUE);
 
 
 </script>
 
 
</body>
</html>